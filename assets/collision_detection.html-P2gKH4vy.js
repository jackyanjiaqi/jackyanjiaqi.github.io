import{_ as l,c as p,a,b as s,d as t,e as o,f as i,r as c,o as d}from"./app-BZlJFCNj.js";const r={};function u(h,n){const e=c("RouteLink");return d(),p("div",null,[n[24]||(n[24]=a("h1",{id:"collision-detection",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#collision-detection"},[a("span",null,"Collision Detection")])],-1)),n[25]||(n[25]=a("p",null,"Collision detection is needed in most games to detect and act upon two components intersecting each other. For example an arrow hitting an enemy or the player picking up a coin.",-1)),a("p",null,[n[1]||(n[1]=s("In most collision detection systems you use something called hitboxes to create more precise bounding boxes of your components. In Flame the hitboxes are areas of the component that can react to collisions (and make ")),t(e,{to:"/guide/flame/inputs/gesture_input.html#gesturehitboxes"},{default:o(()=>n[0]||(n[0]=[s("gesture input")])),_:1}),n[2]||(n[2]=s(") more accurate."))]),n[26]||(n[26]=i(`<p>The collision detection system supports three different types of shapes that you can build hitboxes from, these shapes are Polygon, Rectangle and Circle. Multiple hitbox can be added to a component to form the area which can be used to either detect collisions or whether it contains a point or not, the latter is very useful for accurate gesture detection. The collision detection does not handle what should happen when two hitboxes collide, so it is up to the user to implement what will happen when for example two <code>PositionComponent</code>s have intersecting hitboxes.</p><p>Do note that the built-in collision detection system does not take collisions between two hitboxes that overshoot each other into account, this could happen when they either move very fast or <code>update</code> being called with a large delta time (for example if your app is not in the foreground). This behavior is called tunneling, if you want to read more about it.</p><p>Also note that the collision detection system has a limitation that makes it not work properly if you have certain types of combinations of flips and scales of the ancestors of the hitboxes.</p><h2 id="mixins" tabindex="-1"><a class="header-anchor" href="#mixins"><span>Mixins</span></a></h2><h3 id="hascollisiondetection" tabindex="-1"><a class="header-anchor" href="#hascollisiondetection"><span>HasCollisionDetection</span></a></h3><p>If you want to use collision detection in your game you have to add the <code>HasCollisionDetection</code> mixin to your game so that it can keep track of the components that can collide.</p><p>Example:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyGame</span> <span class="token keyword">extends</span> <span class="token class-name">FlameGame</span> <span class="token keyword">with</span> <span class="token class-name">HasCollisionDetection</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now when you add <code>ShapeHitbox</code>s to components that are then added to the game, they will automatically be checked for collisions.</p><p>You can also add <code>HasCollisionDetection</code> directly to another <code>Component</code> instead of the <code>FlameGame</code>, for example to the <code>World</code> that is used for the <code>CameraComponent</code>. If that is done, hitboxes that are added in that component&#39;s tree will only be compared to other hitboxes in that subtree, which makes it possible to have several worlds with collision detection within one <code>FlameGame</code>.</p><p>Example:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">CollisionDetectionWorld</span> <span class="token keyword">extends</span> <span class="token class-name">World</span> <span class="token keyword">with</span> <span class="token class-name">HasCollisionDetection</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">{note}</span>
<span class="line">Hitboxes will only be connected to one collision detection system and that is</span>
<span class="line">the closest parent that has the \`HasCollisionDetection\` mixin.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="collisioncallbacks" tabindex="-1"><a class="header-anchor" href="#collisioncallbacks"><span>CollisionCallbacks</span></a></h3><p>To react to a collision you should add the <code>CollisionCallbacks</code> mixin to your component. Example:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">{flutter-app}</span>
<span class="line">:sources: ../flame/examples</span>
<span class="line">:page: collision_detection</span>
<span class="line">:show: widget code infobox</span>
<span class="line">:width: 180</span>
<span class="line">:height: 160</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyCollidable</span> <span class="token keyword">extends</span> <span class="token class-name">PositionComponent</span> <span class="token keyword">with</span> <span class="token class-name">CollisionCallbacks</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">onCollision</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Vector2</span><span class="token punctuation">&gt;</span></span> points<span class="token punctuation">,</span> <span class="token class-name">PositionComponent</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">is</span> <span class="token class-name">ScreenHitbox</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">//...</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">is</span> <span class="token class-name">YourOtherComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">//...</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">onCollisionEnd</span><span class="token punctuation">(</span><span class="token class-name">PositionComponent</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">is</span> <span class="token class-name">ScreenHitbox</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">//...</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">is</span> <span class="token class-name">YourOtherComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">//...</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example we use Dart&#39;s <code>is</code> keyword to check what kind of component we collided with. The set of points is where the edges of the hitboxes intersect.</p><p>Note that the <code>onCollision</code> method will be called on both <code>PositionComponent</code>s if they have both implemented the <code>onCollision</code> method, and also on both hitboxes. The same goes for the <code>onCollisionStart</code> and <code>onCollisionEnd</code> methods, which are called when two components and hitboxes starts or stops colliding with each other.</p><p>When a <code>PositionComponent</code> (and hitbox) starts to collide with another <code>PositionComponent</code> both <code>onCollisionStart</code> and <code>onCollision</code> are called, so if you don&#39;t need to do something specific when a collision starts you only need to override <code>onCollision</code>, and vice versa.</p><p>If you want to check collisions with the screen edges, as we do in the example above, you can use the predefined <a href="#screenhitbox">ScreenHitbox</a> class.</p><p>By default all hitboxes are hollow, this means that one hitbox can be fully enclosed by another hitbox without triggering a collision. If you want to set your hitboxes to be solid you can set <code>isSolid = true</code>. A hollow hitbox inside of a solid hitbox will trigger a collision, but not the other way around. If there are no intersections with the edges on a solid hitbox the center position is instead returned.</p><h3 id="collision-order" tabindex="-1"><a class="header-anchor" href="#collision-order"><span>Collision order</span></a></h3><p>If a <code>Hitbox</code> collides with more than one other <code>Hitbox</code> within a given time step, then the <code>onCollision</code> callbacks will be called in an essentially random order. In some cases this can be a problem, such as in a bouncing ball game where the trajectory of the ball can differ depending on which other object was hit first. To help resolve this the <code>collisionsCompletedNotifier</code> listener can be used - this triggers at the end of the collision detection process.</p><p>An example of how this might be used is to add a local variable in your <code>PositionComponent</code> to save the other components with which it&#39;s colliding: <code>List&lt;PositionComponent&gt; collisionComponents = [];</code>. The <code>onCollision</code> callback is then used to save all the other <code>PositionComponent</code>s to this list:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token metadata function">@override</span></span>
<span class="line"><span class="token keyword">void</span> <span class="token function">onCollision</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Vector2</span><span class="token punctuation">&gt;</span></span> intersectionPoints<span class="token punctuation">,</span> <span class="token class-name">PositionComponent</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  collisionComponents<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCollision</span><span class="token punctuation">(</span>intersectionPoints<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Finally, one adds a listener to the <code>onLoad</code> method of the <code>PositionComponent</code> to call a function which will resolve how the collisions should be dealt with:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token punctuation">(</span>game <span class="token operator">as</span> <span class="token class-name">HasCollisionDetection</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span>collisionDetection</span>
<span class="line">    <span class="token punctuation">.</span>collisionsCompletedNotifier</span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">resolveCollisions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The list <code>collisionComponents</code> would need to be cleared in each call to <code>update</code>.</p><h2 id="shapehitbox" tabindex="-1"><a class="header-anchor" href="#shapehitbox"><span>ShapeHitbox</span></a></h2><p>The <code>ShapeHitbox</code>s are normal components, so you add them to the component that you want to add hitboxes to just like any other component:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">PositionComponent</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">onLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">RectangleHitbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If you don&#39;t add any arguments to the hitbox, like above, the hitbox will try to fill its parent as much as possible. Except for having the hitboxes trying to fill their parents, there are two ways to initiate hitboxes and it is with the normal constructor where you define the hitbox by itself, with a size and a position etc. The other way is to use the <code>relative</code> constructor which defines the hitbox in relation to the size of its intended parent.</p><p>In some specific cases you might want to handle collisions only between hitboxes, without propagating <code>onCollision*</code> events to the hitbox&#39;s parent component. For example, a vehicle could have a body hitbox to control collisions and side hitboxes to check the possibility to turn left or right. So, colliding with a body hitbox means colliding with the component itself, whereas colliding with a side hitbox does not mean a real collision and should not be propagated to hitbox&#39;s parent. For this case you can set <code>triggersParentCollision</code> variable to <code>false</code>:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">PositionComponent</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">  late <span class="token keyword">final</span> <span class="token class-name">MySpecialHitbox</span> utilityHitbox<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">onLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    utilityHitbox <span class="token operator">=</span> <span class="token class-name">MySpecialHitbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">add</span><span class="token punctuation">(</span>utilityHitbox<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>double dt<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>utilityHitbox<span class="token punctuation">.</span>isColliding<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// do some specific things if hitbox is colliding</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">// component&#39;s onCollision* functions, ignoring MySpecialHitbox collisions.</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">MySpecialHitbox</span> <span class="token keyword">extends</span> <span class="token class-name">RectangleHitbox</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token class-name">MySpecialHitbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    triggersParentCollision <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// hitbox specific onCollision* functions</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,35)),a("p",null,[n[4]||(n[4]=s("You can read more about how the different shapes are defined in the ")),t(e,{to:"/guide/flame/components.html#shapecomponents"},{default:o(()=>n[3]||(n[3]=[s("ShapeComponents")])),_:1}),n[5]||(n[5]=s(" section."))]),n[27]||(n[27]=a("p",null,[s("Remember that you can add as many "),a("code",null,"ShapeHitbox"),s("s as you want to your "),a("code",null,"PositionComponent"),s(" to make up more complex areas. For example a snowman with a hat could be represented by three "),a("code",null,"CircleHitbox"),s("s and two "),a("code",null,"RectangleHitbox"),s("s as its hat.")],-1)),a("p",null,[n[7]||(n[7]=s("A hitbox can be used either for collision detection or for making gesture detection more accurate on top of components, see more regarding the latter in the section about the ")),t(e,{to:"/guide/flame/inputs/gesture_input.html#gesturehitboxes"},{default:o(()=>n[6]||(n[6]=[s("GestureHitboxes")])),_:1}),n[8]||(n[8]=s(" mixin."))]),n[28]||(n[28]=i('<h3 id="collisiontype" tabindex="-1"><a class="header-anchor" href="#collisiontype"><span>CollisionType</span></a></h3><p>The hitboxes have a field called <code>collisionType</code> which defines when a hitbox should collide with another. Usually you want to set as many hitboxes as possible to <code>CollisionType.passive</code> to make the collision detection more performant. By default the <code>CollisionType</code> is <code>active</code>.</p><p>The <code>CollisionType</code> enum contains the following values:</p><ul><li><code>active</code> collides with other <code>Hitbox</code>es of type active or passive</li><li><code>passive</code> collides with other <code>Hitbox</code>es of type active</li><li><code>inactive</code> will not collide with any other <code>Hitbox</code>es</li></ul><p>So if you have hitboxes that you don&#39;t need to check collisions against each other you can mark them as passive by setting <code>collisionType: CollisionType.passive</code> in the constructor, this could for example be ground components or maybe your enemies don&#39;t need to check collisions between each other, then they could be marked as <code>passive</code> too.</p><p>Imagine a game where there are a lot of bullets, that can&#39;t collide with each other, flying towards the player, then the player would be set to <code>CollisionType.active</code> and the bullets would be set to <code>CollisionType.passive</code>.</p><p>Then we have the <code>inactive</code> type which simply doesn&#39;t get checked at all in the collision detection. This could be used for example if you have components outside of the screen that you don&#39;t care about at the moment but that might later come back in to view so they are not completely removed from the game.</p><p>These are just examples of how you could use these types, there will be a lot more use cases for them so don&#39;t doubt to use them even if your use case isn&#39;t listed here.</p><h3 id="polygonhitbox" tabindex="-1"><a class="header-anchor" href="#polygonhitbox"><span>PolygonHitbox</span></a></h3><p>It should be noted that if you want to use collision detection or <code>containsPoint</code> on the <code>Polygon</code>, the polygon needs to be convex. So always use convex polygons or you will most likely run into problems if you don&#39;t really know what you are doing.</p><p>The other hitbox shapes don&#39;t have any mandatory constructor, that is because they can have a default calculated from the size of the collidable that they are attached to, but since a polygon can be made in an infinite number of ways inside of a bounding box you have to add the definition in the constructor for this shape.</p>',11)),a("p",null,[n[10]||(n[10]=s("The ")),n[11]||(n[11]=a("code",null,"PolygonHitbox",-1)),n[12]||(n[12]=s(" has the same constructors as the ")),t(e,{to:"/guide/flame/components.html#polygoncomponent"},{default:o(()=>n[9]||(n[9]=[s("components.md#polygoncomponent")])),_:1}),n[13]||(n[13]=s(", see that section for documentation regarding those."))]),n[29]||(n[29]=a("h3",{id:"rectanglehitbox",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#rectanglehitbox"},[a("span",null,"RectangleHitbox")])],-1)),a("p",null,[n[15]||(n[15]=s("The ")),n[16]||(n[16]=a("code",null,"RectangleHitbox",-1)),n[17]||(n[17]=s(" has the same constructors as the ")),t(e,{to:"/guide/flame/components.html#rectanglecomponent"},{default:o(()=>n[14]||(n[14]=[s("components.md#rectanglecomponent")])),_:1}),n[18]||(n[18]=s(", see that section for documentation regarding those."))]),n[30]||(n[30]=a("h3",{id:"circlehitbox",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#circlehitbox"},[a("span",null,"CircleHitbox")])],-1)),a("p",null,[n[20]||(n[20]=s("The ")),n[21]||(n[21]=a("code",null,"CircleHitbox",-1)),n[22]||(n[22]=s(" has the same constructors as the ")),t(e,{to:"/guide/flame/components.html#circlecomponent"},{default:o(()=>n[19]||(n[19]=[s("components.md#circlecomponent")])),_:1}),n[23]||(n[23]=s(", see that section for documentation regarding those."))]),n[31]||(n[31]=i(`<h2 id="screenhitbox" tabindex="-1"><a class="header-anchor" href="#screenhitbox"><span>ScreenHitbox</span></a></h2><p><code>ScreenHitbox</code> is a component which represents the edges of your viewport/screen. If you add a <code>ScreenHitbox</code> to your game your other components with hitboxes will be notified when they collide with the edges. It doesn&#39;t take any arguments, it only depends on the <code>size</code> of the game that it is added to. To add it you can just do <code>add(ScreenHitbox())</code> in your game, if you don&#39;t want the <code>ScreenHitbox</code> itself to be notified when something collides with it. Since <code>ScreenHitbox</code> has the <code>CollisionCallbacks</code> mixin you can add your own <code>onCollisionCallback</code>, <code>onStartCollisionCallback</code> and <code>onEndCollisionCallback</code> functions to that object if needed.</p><h2 id="compositehitbox" tabindex="-1"><a class="header-anchor" href="#compositehitbox"><span>CompositeHitbox</span></a></h2><p>In the <code>CompositeHitbox</code> you can add multiple hitboxes so that they emulate being one joined hitbox.</p><p>If you want to form a hat for example you might want to use two <a href="#rectanglehitbox">#rectanglehitbox</a>s to follow that hat&#39;s edges properly, then you can add those hitboxes to an instance of this class and react to collisions to the whole hat, instead of for just each hitbox separately.</p><h2 id="broad-phase" tabindex="-1"><a class="header-anchor" href="#broad-phase"><span>Broad phase</span></a></h2><p>If your game field isn&#39;t huge and does not have a lot of collidable components - you don&#39;t have to worry about the broad phase system that is used, so if the standard implementation is performant enough for you, you probably don&#39;t have to read this section.</p><p>A broad phase is the first step of collision detection where potential collisions are calculated. Calculating these potential collisions is faster than to checking the intersections exactly, and it removes the need to check all hitboxes against each other and therefore avoiding O(n²).</p><p>The broad phase produces a set of potential collisions (a set of <code>CollisionProspect</code>s). This set is then used to check the exact intersections between hitboxes (sometimes called &quot;narrow phase&quot;).</p><p>By default, Flame&#39;s collision detection is using a sweep and prune broadphase step. If your game requires another type of broadphase you can write your own broadphase by extending <code>Broadphase</code> and manually setting the collision detection system that should be used.</p><p>For example, if you have implemented a broadphase built on a magic algorithm instead of the standard sweep and prune, then you would do the following:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyGame</span> <span class="token keyword">extends</span> <span class="token class-name">FlameGame</span> <span class="token keyword">with</span> <span class="token class-name">HasCollisionDetection</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token class-name">MyGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    collisionDetection <span class="token operator">=</span></span>
<span class="line">        <span class="token class-name">StandardCollisionDetection</span><span class="token punctuation">(</span>broadphase<span class="token punctuation">:</span> <span class="token class-name">MagicAlgorithmBroadphase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="quad-tree-broad-phase" tabindex="-1"><a class="header-anchor" href="#quad-tree-broad-phase"><span>Quad Tree broad phase</span></a></h2><p>If your game field is large and the game contains a lot of collidable components (more than a hundred), standard sweep and prune can become inefficient. If it does, you can try to use the quad tree broad phase.</p><p>To do this, add the <code>HasQuadTreeCollisionDetection</code> mixin to your game instead of <code>HasCollisionDetection</code> and call the <code>initializeCollisionDetection</code> function on game load:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyGame</span> <span class="token keyword">extends</span> <span class="token class-name">FlameGame</span> <span class="token keyword">with</span> <span class="token class-name">HasQuadTreeCollisionDetection</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">onLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">initializeCollisionDetection</span><span class="token punctuation">(</span></span>
<span class="line">      mapDimensions<span class="token punctuation">:</span> <span class="token keyword">const</span> <span class="token class-name">Rect</span><span class="token punctuation">.</span><span class="token function">fromLTWH</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mapWidth<span class="token punctuation">,</span> mapHeight<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">      minimumDistance<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>When calling <code>initializeCollisionDetection</code> you should pass it the correct map dimensions, to make the quad tree algorithm to work properly. There are also additional parameters to make the system more efficient:</p><ul><li><code>minimumDistance</code>: minimum distance between objects to consider them as possibly colliding. If <code>null</code> - the check is disabled, it is default behavior</li><li><code>maxObjects</code>: maximum objects count in one quadrant. Default to 25.</li><li><code>maxDepth</code>: maximum nesting levels inside quadrant. Default to 10</li></ul><p>If you use the quad tree system, you can make it even more efficient by implementing the <code>onComponentTypeCheck</code> function of the <code>CollisionCallbacks</code> mixin in your components. It is useful if you need to prevent collisions of items of different types. The result of the calculation is cached so you should not check any dynamic parameters here, the function is intended to be used as a pure type checker:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Bullet</span> <span class="token keyword">extends</span> <span class="token class-name">PositionComponent</span> <span class="token keyword">with</span> <span class="token class-name">CollisionCallbacks</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  bool <span class="token function">onComponentTypeCheck</span><span class="token punctuation">(</span><span class="token class-name">PositionComponent</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">is</span> <span class="token class-name">Player</span> <span class="token operator">||</span> other <span class="token operator">is</span> <span class="token class-name">Water</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// do NOT collide with Player or Water</span></span>
<span class="line">      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// Just return true if you&#39;re not interested in the parent&#39;s type check result.</span></span>
<span class="line">    <span class="token comment">// Or call super and you will be able to override the result with the parent&#39;s</span></span>
<span class="line">    <span class="token comment">// result.</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onComponentTypeCheck</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">onCollisionStart</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Vector2</span><span class="token punctuation">&gt;</span></span> intersectionPoints<span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">PositionComponent</span> other<span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// Removes the component when it comes in contact with a Brick.</span></span>
<span class="line">    <span class="token comment">// Neither Player nor Water would be passed to this function</span></span>
<span class="line">    <span class="token comment">// because these classes are filtered out by [onComponentTypeCheck]</span></span>
<span class="line">    <span class="token comment">// in an earlier stage.</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>other <span class="token operator">is</span> <span class="token class-name">Brick</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">removeFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCollisionStart</span><span class="token punctuation">(</span>intersectionPoints<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>After intensive gameplay a map could become over-clusterized with a lot of empty quadrants. Run <code>QuadTree.optimize()</code> to perform a cleanup of empty quadrants:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">QuadTreeExample</span> <span class="token keyword">extends</span> <span class="token class-name">FlameGame</span></span>
<span class="line">        <span class="token keyword">with</span> <span class="token class-name">HasQuadTreeCollisionDetection</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">/// A function called when intensive gameplay session is over</span></span>
<span class="line">  <span class="token comment">/// It also might be scheduled, but no need to run it on every update.</span></span>
<span class="line">  <span class="token comment">/// Use right interval depending on your game circumstances</span></span>
<span class="line">  <span class="token function">onGameIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token punctuation">(</span>collisionDetection <span class="token operator">as</span> <span class="token class-name">QuadTreeCollisionDetection</span><span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">.</span>quadBroadphase</span>
<span class="line">            <span class="token punctuation">.</span>tree</span>
<span class="line">            <span class="token punctuation">.</span><span class="token function">optimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Always experiment with different collision detection approaches</span>
<span class="line">and check how they perform on your game.</span>
<span class="line">It is not unheard of that \`QuadTreeBroadphase\` is significantly </span>
<span class="line">_slower_ than the default.</span>
<span class="line">Don&#39;t assume that the more sophisticated approach is always faster.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="ray-casting-and-ray-tracing" tabindex="-1"><a class="header-anchor" href="#ray-casting-and-ray-tracing"><span>Ray casting and Ray tracing</span></a></h2><p>Ray casting and ray tracing are methods for sending out rays from a point in your game and being able to see what these rays collide with and how they reflect after hitting something.</p><p>For all of the following methods, if there are any hitboxes that you wish to ignore, you can add the <code>ignoreHitboxes</code> argument which is a list of the hitboxes that you wish to disregard for the call. This can be quite useful for example if you are casting rays from within a hitbox, which could be on your player or NPC; or if you don&#39;t want a ray to bounce off a <code>ScreenHitbox</code>.</p><h3 id="ray-casting" tabindex="-1"><a class="header-anchor" href="#ray-casting"><span>Ray casting</span></a></h3><p>Ray casting is the operation of casting out one or more rays from a point and see if they hit anything, in Flame&#39;s case, hitboxes.</p><p>We provide two methods for doing so, <code>raycast</code> and <code>raycastAll</code>. The first one just casts out a single ray and gets back a result with information about what and where the ray hit, and some extra information like the distance, the normal and the reflection ray. The second one, <code>raycastAll</code>, works similarly but sends out multiple rays uniformly around the origin, or within an angle centered at the origin.</p><p>By default, <code>raycast</code> and <code>raycastAll</code> scan for the nearest hit irrespective of how far it lies from the ray origin. But in some use cases, it might be interesting to find hits only within a certain range. For such cases, an optional <code>maxDistance</code> can be provided.</p><p>To use the ray casting functionality you have to have the <code>HasCollisionDetection</code> mixin on your game. After you have added that you can call <code>collisionDetection.raycast(...)</code> on your game class.</p><p>Example:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">{flutter-app}</span>
<span class="line">:sources: ../flame/examples</span>
<span class="line">:page: ray_cast</span>
<span class="line">:show: widget code infobox</span>
<span class="line">:width: 180</span>
<span class="line">:height: 160</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyGame</span> <span class="token keyword">extends</span> <span class="token class-name">FlameGame</span> <span class="token keyword">with</span> <span class="token class-name">HasCollisionDetection</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>double dt<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>dt<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">final</span> ray <span class="token operator">=</span> <span class="token class-name">Ray2</span><span class="token punctuation">(</span></span>
<span class="line">        origin<span class="token punctuation">:</span> <span class="token class-name">Vector2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        direction<span class="token punctuation">:</span> <span class="token class-name">Vector2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">final</span> result <span class="token operator">=</span> collisionDetection<span class="token punctuation">.</span><span class="token function">raycast</span><span class="token punctuation">(</span>ray<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example one can see that the <code>Ray2</code> class is being used, this class defines a ray from an origin position and a direction (which are both defined by <code>Vector2</code>s). This particular ray starts from <code>0, 100</code> and shoots a ray straight to the right.</p><p>The result from this operation will either be <code>null</code> if the ray didn&#39;t hit anything, or a <code>RaycastResult</code> which contains:</p><ul><li>Which hitbox the ray hit</li><li>The intersection point of the collision</li><li>The reflection ray, i.e. how the ray would reflect on the hitbox that it hix</li><li>The normal of the collision, i.e. a vector perpendicular to the face of the hitbox that it hits</li></ul><p>If you are concerned about performance you can pre create a <code>RaycastResult</code> object that you send in to the method with the <code>out</code> argument, this will make it possible for the method to reuse this object instead of creating a new one for each iteration. This can be good if you do a lot of ray casting in your <code>update</code> methods.</p><h4 id="raycastall" tabindex="-1"><a class="header-anchor" href="#raycastall"><span>raycastAll</span></a></h4><p>Sometimes you want to send out rays in all, or a limited range, of directions from an origin. This can have a lot of applications, for example you could calculate the field of view of a player or enemy, or it can also be used to create light sources.</p><p>Example:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyGame</span> <span class="token keyword">extends</span> <span class="token class-name">FlameGame</span> <span class="token keyword">with</span> <span class="token class-name">HasCollisionDetection</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>double dt<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>dt<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">final</span> origin <span class="token operator">=</span> <span class="token class-name">Vector2</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">final</span> result <span class="token operator">=</span> collisionDetection<span class="token punctuation">.</span><span class="token function">raycastAll</span><span class="token punctuation">(</span></span>
<span class="line">      origin<span class="token punctuation">,</span></span>
<span class="line">      numberOfRays<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example we would send out 100 rays from (200, 200) uniformly spread in all directions.</p><p>If you want to limit the directions you can use the <code>startAngle</code> and the <code>sweepAngle</code> arguments. Where the <code>startAngle</code> (counting from straight up) is where the rays will start and then the rays will end at <code>startAngle + sweepAngle</code>.</p><p>If you are concerned about performance you can re-use the <code>RaycastResult</code> objects that are created by the function by sending them in as a list with the <code>out</code> argument.</p><h3 id="ray-tracing" tabindex="-1"><a class="header-anchor" href="#ray-tracing"><span>Ray tracing</span></a></h3><p>Ray tracing is similar to ray casting, but instead of just checking what the ray hits you can continue to trace the ray and see what its reflection ray (the ray bouncing off the hitbox) will hit and then what that casted reflection ray&#39;s reflection ray will hit and so on, until you decide that you have traced the ray for long enough. If you imagine how a pool ball would bounce on a pool table for example, that information could be retrieved with the help of ray tracing.</p><p>Example:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">{flutter-app}</span>
<span class="line">:sources: ../flame/examples</span>
<span class="line">:page: ray_trace</span>
<span class="line">:show: widget code infobox</span>
<span class="line">:width: 180</span>
<span class="line">:height: 160</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyGame</span> <span class="token keyword">extends</span> <span class="token class-name">FlameGame</span> <span class="token keyword">with</span> <span class="token class-name">HasCollisionDetection</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>double dt<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>dt<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">final</span> ray <span class="token operator">=</span> <span class="token class-name">Ray2</span><span class="token punctuation">(</span></span>
<span class="line">        origin<span class="token punctuation">:</span> <span class="token class-name">Vector2</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        direction<span class="token punctuation">:</span> <span class="token class-name">Vector2</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">final</span> results <span class="token operator">=</span> collisionDetection<span class="token punctuation">.</span><span class="token function">raytrace</span><span class="token punctuation">(</span></span>
<span class="line">      ray<span class="token punctuation">,</span></span>
<span class="line">      maxDepth<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">final</span> result <span class="token keyword">in</span> results<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>intersectionPoint<span class="token punctuation">.</span><span class="token function">distanceTo</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>origin<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">break</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the example above we send out a ray from (0, 100) diagonally down to the right and we say that we want it the bounce on at most 100 hitboxes, it doesn&#39;t necessarily have to get 100 results since at some point one of the reflection rays might not hit a hitbox and then the method is done.</p><p>The method is lazy, which means that it will only do the calculations that you ask for, so you have to loop through the iterable that it returns to get the results, or do <code>toList()</code> to directly calculate all the results.</p><p>In the for-loop it can be seen how this can be used, in that loop we check whether the current reflection rays intersection point (where the previous ray hit the hitbox) is further away than 300 pixels from the origin of the starting ray, and if it is we don&#39;t care about the rest of the results (and then they don&#39;t have to be calculated either).</p><p>If you are concerned about performance you can re-use the <code>RaycastResult</code> objects that are created by the function by sending them in as a list with the <code>out</code> argument.</p><h2 id="comparison-to-forge2d" tabindex="-1"><a class="header-anchor" href="#comparison-to-forge2d"><span>Comparison to Forge2D</span></a></h2><p>If you want to have a full-blown physics engine in your game we recommend that you use Forge2D by adding <a href="https://github.com/flame-engine/flame_forge2d" target="_blank" rel="noopener noreferrer">flame_forge2d</a> as a dependency. But if you have a simpler use-case and just want to check for collisions of components and improve the accuracy of gestures, Flame&#39;s built-in collision detection will serve you very well.</p><p>If you have the following needs you should at least consider to use <a href="https://github.com/flame-engine/forge2d" target="_blank" rel="noopener noreferrer">Forge2D</a>:</p><ul><li>Interacting realistic forces</li><li>Particle systems that can interact with other bodies</li><li>Joints between bodies</li></ul><p>It is a good idea to just use the Flame collision detection system if you on the other hand only need some of the following things (since it is simpler to not involve Forge2D):</p><ul><li>The ability to act on some of your components colliding</li><li>The ability to act on your components colliding with the screen boundaries</li><li>Complex shapes to act as a hitbox for your component so that gestures will be more accurate</li><li>Hitboxes that can tell what part of a component that collided with something</li></ul><h2 id="examples" tabindex="-1"><a class="header-anchor" href="#examples"><span>Examples</span></a></h2><ul><li><a href="https://examples.flame-engine.org/#/Collision_Detection_Collidable_AnimationComponent" target="_blank" rel="noopener noreferrer">Collidable AnimationComponent</a></li><li><a href="https://examples.flame-engine.org/#/Collision_Detection_Circles" target="_blank" rel="noopener noreferrer">Circles</a></li><li><a href="https://examples.flame-engine.org/#/Collision_Detection_Multiple_shapes" target="_blank" rel="noopener noreferrer">Multiple shapes</a></li><li><a href="https://github.com/flame-engine/flame/tree/main/examples/lib/stories/collision_detection" target="_blank" rel="noopener noreferrer">More Examples</a></li></ul>`,62))])}const k=l(r,[["render",u],["__file","collision_detection.html.vue"]]),b=JSON.parse('{"path":"/guide/flame/collision_detection.html","title":"Collision Detection","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Mixins","slug":"mixins","link":"#mixins","children":[{"level":3,"title":"HasCollisionDetection","slug":"hascollisiondetection","link":"#hascollisiondetection","children":[]},{"level":3,"title":"CollisionCallbacks","slug":"collisioncallbacks","link":"#collisioncallbacks","children":[]},{"level":3,"title":"Collision order","slug":"collision-order","link":"#collision-order","children":[]}]},{"level":2,"title":"ShapeHitbox","slug":"shapehitbox","link":"#shapehitbox","children":[{"level":3,"title":"CollisionType","slug":"collisiontype","link":"#collisiontype","children":[]},{"level":3,"title":"PolygonHitbox","slug":"polygonhitbox","link":"#polygonhitbox","children":[]},{"level":3,"title":"RectangleHitbox","slug":"rectanglehitbox","link":"#rectanglehitbox","children":[]},{"level":3,"title":"CircleHitbox","slug":"circlehitbox","link":"#circlehitbox","children":[]}]},{"level":2,"title":"ScreenHitbox","slug":"screenhitbox","link":"#screenhitbox","children":[]},{"level":2,"title":"CompositeHitbox","slug":"compositehitbox","link":"#compositehitbox","children":[]},{"level":2,"title":"Broad phase","slug":"broad-phase","link":"#broad-phase","children":[]},{"level":2,"title":"Quad Tree broad phase","slug":"quad-tree-broad-phase","link":"#quad-tree-broad-phase","children":[]},{"level":2,"title":"Ray casting and Ray tracing","slug":"ray-casting-and-ray-tracing","link":"#ray-casting-and-ray-tracing","children":[{"level":3,"title":"Ray casting","slug":"ray-casting","link":"#ray-casting","children":[]},{"level":3,"title":"Ray tracing","slug":"ray-tracing","link":"#ray-tracing","children":[]}]},{"level":2,"title":"Comparison to Forge2D","slug":"comparison-to-forge2d","link":"#comparison-to-forge2d","children":[]},{"level":2,"title":"Examples","slug":"examples","link":"#examples","children":[]}],"git":{"updatedTime":1735588798000,"contributors":[{"name":"JackYanjiaqi","username":"JackYanjiaqi","email":"jackyanjiaqi@gmail.com","commits":1,"url":"https://github.com/JackYanjiaqi"}]},"filePathRelative":"guide/flame/collision_detection.md"}');export{k as comp,b as data};
