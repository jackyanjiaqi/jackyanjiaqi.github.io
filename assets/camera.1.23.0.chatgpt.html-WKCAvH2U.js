import{_ as o,c,f as e,a as s,b as a,d as t,e as l,r as i,o as d}from"./app-BZlJFCNj.js";const r={};function u(m,n){const p=i("RouteLink");return d(),c("div",null,[n[7]||(n[7]=e(`<h1 id="相机与世界" tabindex="-1"><a class="header-anchor" href="#相机与世界"><span>相机与世界</span></a></h1><p><a href="https://immvpc32u2.feishu.cn/docx/QjHbd9ikvo9f87xr1EgcLMrdnte?from=from_copylink" target="_blank" rel="noopener noreferrer">教学笔记: 加群可访问</a></p><p>以下是一个简单游戏结构的示例：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">FlameGame</span>
<span class="line">├── World</span>
<span class="line">│   ├── Player</span>
<span class="line">│   └── Enemy</span>
<span class="line">└── CameraComponent</span>
<span class="line">    ├── Viewfinder</span>
<span class="line">    │   ├── HudButton</span>
<span class="line">    │   └── FpsTextComponent</span>
<span class="line">    └── Viewport</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了理解 <code>CameraComponent</code> 的工作原理，可以想象你的游戏世界是一个独立存在的实体，独立于你的应用程序之外。想象你的游戏只是一扇窗户，通过这扇窗户你可以看到那个世界。你可以随时关闭这扇窗户，游戏世界依然存在。或者相反，你可以同时打开多扇窗户来观察同一个世界（或不同的世界）。</p><p>基于这个概念，我们可以深入理解 <code>CameraComponent</code> 的工作原理。</p><p>首先，有一个 <a href="#world">World</a> 类，它包含游戏世界内的所有组件。<code>World</code> 组件可以被挂载在任何地方，例如在你的游戏类的根部，就像内置的 <code>World</code> 那样。</p><p>然后是 <a href="#cameracomponent">CameraComponent</a> 类，它“观察”<a href="#world">World</a>。<code>CameraComponent</code> 包含 <a href="#viewport">Viewport</a> 和 <a href="#viewfinder">Viewfinder</a>，提供了在屏幕上任意位置渲染世界的灵活性，并控制观察位置和角度。此外，<code>CameraComponent</code> 还包含一个 <a href="#backdrop">backdrop</a> 组件，用于在世界下方静态渲染内容。</p><hr><h2 id="world" tabindex="-1"><a class="header-anchor" href="#world"><span>World</span></a></h2><p>此组件用于容纳构成游戏世界的所有其他组件。<code>World</code> 类的主要特性是它并不通过传统方式渲染，而是通过一个或多个 <a href="#cameracomponent">CameraComponent</a> 来“观察”世界。在 <code>FlameGame</code> 类中，默认有一个 <code>World</code>，名为 <code>world</code>，它与默认的 <code>CameraComponent</code>（名为 <code>camera</code>）配对。</p><p>一个游戏可以包含多个 <code>World</code> 实例，可以同时渲染或分时渲染。例如，如果你有两个世界 A 和 B，并且只有一个相机，那么将相机的目标从 A 切换到 B 会即时切换视图，而无需卸载 A 再加载 B。</p><p>与大多数 <code>Component</code> 一样，可以通过构造函数中的 <code>children</code> 参数，或者使用 <code>add</code> 和 <code>addAll</code> 方法向 <code>World</code> 添加子组件。</p><p>对于许多游戏，你可能需要扩展 <code>World</code> 并在其中创建逻辑，例如：</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">runApp</span><span class="token punctuation">(</span><span class="token class-name">GameWidget</span><span class="token punctuation">(</span><span class="token class-name">FlameGame</span><span class="token punctuation">(</span>world<span class="token punctuation">:</span> <span class="token class-name">MyWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">MyWorld</span> <span class="token keyword">extends</span> <span class="token class-name">World</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">void</span><span class="token punctuation">&gt;</span></span> <span class="token function">onLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 加载此世界需要的所有资源，并添加组件等</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="cameracomponent" tabindex="-1"><a class="header-anchor" href="#cameracomponent"><span>CameraComponent</span></a></h2><p>这是一个用于渲染 <code>World</code> 的组件。多个相机可以同时观察同一个世界。</p><p>在 <code>FlameGame</code> 类中，默认有一个 <code>CameraComponent</code>，名为 <code>camera</code>，它与默认的 <code>world</code> 配对，因此如果你的游戏不需要自定义相机，你不需要创建或添加自己的 <code>CameraComponent</code>。</p><p><code>CameraComponent</code> 内有两个其他组件：<a href="#viewport">Viewport</a> 和 <a href="#viewfinder">Viewfinder</a>，它们始终是相机的子组件。</p><p>通过 <code>FlameGame</code> 类的构造函数中的 <code>camera</code> 字段，你可以设置默认相机的类型，例如以下具有<a href="#cameracomponent-with-fixed-resolution">固定分辨率</a>的相机：</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">runApp</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token class-name">GameWidget</span><span class="token punctuation">(</span></span>
<span class="line">      <span class="token class-name">FlameGame</span><span class="token punctuation">(</span></span>
<span class="line">        camera<span class="token punctuation">:</span> <span class="token class-name">CameraComponent</span><span class="token punctuation">.</span><span class="token function">withFixedResolution</span><span class="token punctuation">(</span></span>
<span class="line">          width<span class="token punctuation">:</span> <span class="token number">800</span><span class="token punctuation">,</span></span>
<span class="line">          height<span class="token punctuation">:</span> <span class="token number">600</span><span class="token punctuation">,</span></span>
<span class="line">        <span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">        world<span class="token punctuation">:</span> <span class="token class-name">MyWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">      <span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>CameraComponent</code> 还提供一个静态属性 <code>CameraComponent.currentCamera</code>，返回当前执行渲染的相机对象。这通常用于某些高级用例，例如根据相机设置决定是否渲染某些组件。</p><hr><h3 id="固定分辨率的-cameracomponent" tabindex="-1"><a class="header-anchor" href="#固定分辨率的-cameracomponent"><span>固定分辨率的 CameraComponent</span></a></h3><p>此命名构造函数允许你假设用户的设备具有固定的分辨率，例如：</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">final</span> camera <span class="token operator">=</span> <span class="token class-name">CameraComponent</span><span class="token punctuation">.</span><span class="token function">withFixedResolution</span><span class="token punctuation">(</span></span>
<span class="line">  world<span class="token punctuation">:</span> myWorldComponent<span class="token punctuation">,</span></span>
<span class="line">  width<span class="token punctuation">:</span> <span class="token number">800</span><span class="token punctuation">,</span></span>
<span class="line">  height<span class="token punctuation">:</span> <span class="token number">600</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这将创建一个相机，其视口位于屏幕中央，占用尽可能多的空间，同时保持 4:3（800x600）的宽高比，并显示大小为 800 x 600 的游戏世界区域。</p><p>“固定分辨率”易于处理，但如果用户设备的宽高比与所选分辨率不同，则会浪费屏幕空间。</p><hr><h2 id="viewport" tabindex="-1"><a class="header-anchor" href="#viewport"><span>Viewport</span></a></h2><p><code>Viewport</code> 是观察 <code>World</code> 的窗口。这个窗口有一定的大小、形状和屏幕上的位置。你可以选择多种视口类型，或者实现自己的视口。</p><p><code>Viewport</code> 是一个组件，这意味着你可以向其中添加其他组件。这些子组件会受到视口位置的影响，但不会受到其裁剪区域的影响。因此，如果视口是“窗口”，那么其子组件就是“窗口前”可以看到的内容。</p><p>将元素添加到 <code>Viewport</code> 是实现“HUD”组件的一种便捷方式。</p><p>以下视口类型可用：</p><ul><li><code>MaxViewport</code>（默认）——视口扩展到游戏允许的最大大小，即等于游戏画布的大小。</li><li><code>FixedResolutionViewport</code>——保持固定的分辨率和宽高比，宽高比不匹配时用黑边填充。</li><li><code>FixedSizeViewport</code>——简单的固定大小矩形视口。</li><li><code>FixedAspectRatioViewport</code>——保持宽高比的矩形视口。</li><li><code>CircularViewport</code>——固定大小的圆形视口。</li></ul><p>如果向 <code>Viewport</code> 添加子组件，它们会以静态 HUD 的形式显示在世界前面。</p><hr><h2 id="viewfinder" tabindex="-1"><a class="header-anchor" href="#viewfinder"><span>Viewfinder</span></a></h2><p><code>Viewfinder</code> 负责确定当前观察的游戏世界位置，同时控制缩放级别和视图旋转角度。</p><p><code>Viewfinder</code> 的 <code>anchor</code> 属性允许你指定视口内作为相机“逻辑中心”的点。例如，在横向滚动的动作游戏中，相机通常聚焦在主角身上，但主角可能显示在屏幕左下角附近，而不是屏幕中央。</p><p>向 <code>Viewfinder</code> 添加子组件时，这些组件会显示在世界的前面，但在视口后面，并与世界应用相同的变换，因此它们不是静态的。</p>`,42)),s("p",null,[n[1]||(n[1]=a("你还可以向 ")),n[2]||(n[2]=s("code",null,"Viewfinder",-1)),n[3]||(n[3]=a(" 添加行为组件，例如")),t(p,{to:"/guide/flame/effects.html"},{default:l(()=>n[0]||(n[0]=[a("特效")])),_:1}),n[4]||(n[4]=a("或控制器。例如，添加一个 ")),n[5]||(n[5]=s("code",null,"ScaleEffect",-1)),n[6]||(n[6]=a(" 可以实现平滑的缩放效果。"))]),n[8]||(n[8]=e(`<hr><h2 id="backdrop" tabindex="-1"><a class="header-anchor" href="#backdrop"><span>Backdrop</span></a></h2><p>如果要在世界后方添加静态组件，可以将其添加到 <code>backdrop</code> 组件中，或者替换 <code>backdrop</code> 组件。例如，添加一个静态 <code>ParallaxComponent</code>，显示在拥有移动玩家的世界后面：</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line">camera<span class="token punctuation">.</span>backdrop<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">MyStaticBackground</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line">camera<span class="token punctuation">.</span>backdrop <span class="token operator">=</span> <span class="token class-name">MyStaticBackground</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="相机控制" tabindex="-1"><a class="header-anchor" href="#相机控制"><span>相机控制</span></a></h2><p>可以通过以下几种方式在运行时修改相机的设置：</p><ol><li><p>使用相机函数，例如 <code>follow()</code>、<code>moveBy()</code> 和 <code>moveTo()</code>。 这些函数底层使用与方法 (2) 相同的效果/行为。</p></li><li><p>对相机的 <code>Viewfinder</code> 或 <code>Viewport</code> 应用效果和/或行为。 效果和行为是专门用于随时间修改组件某些属性的特殊组件。</p></li><li><p>手动操作。你可以覆盖 <code>CameraComponent.update()</code> 方法（或视口或取景器上的同名方法），并在其中根据需要更改取景器的位置或缩放级别。这种方法可能适用于某些情况，但通常不推荐。</p></li></ol><p><code>CameraComponent</code> 提供了一些方法用于控制其行为：</p><ul><li><p><code>follow()</code> 使相机跟随指定目标。可以选择限制相机移动的最大速度，或者仅允许水平/垂直移动。</p></li><li><p><code>stop()</code> 取消之前的跟随操作并停止相机在当前位置。</p></li><li><p><code>moveBy()</code> 将相机按指定偏移移动。如果相机已经在跟随其他组件或移动中，这些行为将自动取消。</p></li><li><p><code>moveTo()</code> 将相机移动到世界地图上的指定点。如果相机已经在跟随其他组件或移动到其他点，这些行为将自动取消。</p></li><li><p><code>setBounds()</code> 限制相机的移动范围。这些范围由一个 <code>Shape</code> 定义，通常是矩形，但也可以是其他形状。</p></li></ul><hr><h3 id="visibleworldrect" tabindex="-1"><a class="header-anchor" href="#visibleworldrect"><span>visibleWorldRect</span></a></h3><p>相机提供了属性 <code>visibleWorldRect</code>，描述了通过相机当前可见的世界区域。此区域可用于避免渲染视图外的组件，或减少更新远离玩家的对象的频率。</p><p><code>visibleWorldRect</code> 是一个缓存属性，会在相机移动或视口大小改变时自动更新。</p><hr><h3 id="cansee" tabindex="-1"><a class="header-anchor" href="#cansee"><span>canSee</span></a></h3><p><code>CameraComponent</code> 有一个方法 <code>canSee</code>，可以用来检查某个组件是否在相机视野中。这对于剔除视图外的组件非常有用。</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>camera<span class="token punctuation">.</span><span class="token function">canSee</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">   component<span class="token punctuation">.</span><span class="token function">removeFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 剔除组件</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,20))])}const v=o(r,[["render",u],["__file","camera.1.23.0.chatgpt.html.vue"]]),h=JSON.parse('{"path":"/guide/flame/camera.1.23.0.chatgpt.html","title":"相机与世界","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"World","slug":"world","link":"#world","children":[]},{"level":2,"title":"CameraComponent","slug":"cameracomponent","link":"#cameracomponent","children":[{"level":3,"title":"固定分辨率的 CameraComponent","slug":"固定分辨率的-cameracomponent","link":"#固定分辨率的-cameracomponent","children":[]}]},{"level":2,"title":"Viewport","slug":"viewport","link":"#viewport","children":[]},{"level":2,"title":"Viewfinder","slug":"viewfinder","link":"#viewfinder","children":[]},{"level":2,"title":"Backdrop","slug":"backdrop","link":"#backdrop","children":[]},{"level":2,"title":"相机控制","slug":"相机控制","link":"#相机控制","children":[{"level":3,"title":"visibleWorldRect","slug":"visibleworldrect","link":"#visibleworldrect","children":[]},{"level":3,"title":"canSee","slug":"cansee","link":"#cansee","children":[]}]}],"git":{},"filePathRelative":"guide/flame/camera.1.23.0.chatgpt.md"}');export{v as comp,h as data};
