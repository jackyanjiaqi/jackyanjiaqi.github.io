import{_ as t,c as i,f as n,a as s,b as a,d as c,e as l,r,o as p}from"./app-B8TszOv9.js";const d={};function h(m,e){const o=r("RouteLink");return p(),i("div",null,[e[5]||(e[5]=n(`<h1 id="camera-component" tabindex="-1"><a class="header-anchor" href="#camera-component"><span>Camera component</span></a></h1><p>Camera-as-a-component is the new way of structuring a game, an approach that allows more flexibility in placing the camera, or even having more than one camera simultaneously.</p><p>In order to understand how this approach works, imagine that your game world is an entity that exists <em>somewhere</em> independently from your application. Imagine that your game is merely a window through which you can look into that world. That you can close that window at any moment, and the game world would still be there. Or, on the contrary, you can open multiple windows that all look at the same world (or different worlds) at the same time.</p><p>With this mindset, we can now understand how camera-as-a-component works.</p><p>First, there is the <a href="#world">World</a> class, which contains all components that are inside your game world. The <code>World</code> component can be mounted anywhere, for example at the root of your game class, like the built-in <code>World</code> is.</p><p>Then, a <a href="#cameracomponent">CameraComponent</a> class that &quot;looks at&quot; the <a href="#world">World</a>. The <code>CameraComponent</code> has a <a href="#viewport">Viewport</a> and a <a href="#viewfinder">Viewfinder</a> inside, allowing both the flexibility of rendering the world at any place on the screen, and also control the viewing location and angle. The <code>CameraComponent</code> also contains a <a href="#backdrop">backdrop</a> component which is statically rendered below the world.</p><h2 id="world" tabindex="-1"><a class="header-anchor" href="#world"><span>World</span></a></h2><p>This component should be used to host all other components that comprise your game world. The main property of the <code>World</code> class is that it does not render through traditional means -- instead it is rendered by one or more <a href="#cameracomponent">CameraComponent</a>s to &quot;look at&quot; the world. In the <code>FlameGame</code> class there is one <code>World</code> called <code>world</code> which is added by default and paired together with the default <code>CameraComponent</code> called <code>camera</code>.</p><p>A game can have multiple <code>World</code> instances that can be rendered either at the same time, or at different times. For example, if you have two worlds A and B and a single camera, then switching that camera&#39;s target from A to B will instantaneously switch the view to world B without having to unmount A and then mount B.</p><p>Just like with most <code>Component</code>s, children can be added to <code>World</code> by using the <code>children</code> argument in its constructor, or by using the <code>add</code> or <code>addAll</code> methods.</p><p>For many games you want to extend the world and create your logic in there, such a game structure could look like this:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">runApp</span><span class="token punctuation">(</span><span class="token class-name">GameWidget</span><span class="token punctuation">(</span><span class="token class-name">FlameGame</span><span class="token punctuation">(</span>world<span class="token punctuation">:</span> <span class="token class-name">MyWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">MyWorld</span> <span class="token keyword">extends</span> <span class="token class-name">World</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token metadata function">@override</span></span>
<span class="line">  <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">void</span><span class="token punctuation">&gt;</span></span> <span class="token function">onLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// Load all the assets that are needed in this world</span></span>
<span class="line">    <span class="token comment">// and add components etc.</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="cameracomponent" tabindex="-1"><a class="header-anchor" href="#cameracomponent"><span>CameraComponent</span></a></h2><p>This is a component through which a <code>World</code> is rendered. It requires a reference to a <code>World</code> instance during construction; however later the target world can be replaced with another one. Multiple cameras can observe the same world at the same time.</p><p>There is a default <code>CameraComponent</code> called <code>camera</code> on the <code>FlameGame</code> class which is paired together with the default <code>world</code>, so you don&#39;t need to create or add your own <code>CameraComponent</code> if your game doesn&#39;t need to.</p><p>A <code>CameraComponent</code> has two other components inside: a <a href="#viewport">Viewport</a> and a <a href="#viewfinder">Viewfinder</a>. Unlike the <code>World</code> object, the camera owns the viewport and the viewfinder, which means those components are children of the camera.</p><p>There is also a static property <code>CameraComponent.currentCamera</code> which is not null only during the rendering stage, and it returns the camera object that currently performs rendering. This is needed only for certain advanced use cases where the rendering of a component depends on the camera settings. For example, some components may decide to skip rendering themselves and their children if they are outside of the camera&#39;s viewport.</p><p>The <code>FlameGame</code> class has a <code>camera</code> field in its constructor, so you can set what type of default camera that you want like this for example:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">runApp</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token class-name">GameWidget</span><span class="token punctuation">(</span></span>
<span class="line">      <span class="token class-name">FlameGame</span><span class="token punctuation">(</span></span>
<span class="line">        camera<span class="token punctuation">:</span> <span class="token class-name">CameraComponent</span><span class="token punctuation">.</span><span class="token function">withFixedResolution</span><span class="token punctuation">(</span>width<span class="token punctuation">:</span> <span class="token number">800</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">      <span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="cameracomponent-withfixedresolution" tabindex="-1"><a class="header-anchor" href="#cameracomponent-withfixedresolution"><span>CameraComponent.withFixedResolution()</span></a></h3><p>This factory constructor will let you pretend that the user&#39;s device has a fixed resolution of your choice. For example:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">final</span> camera <span class="token operator">=</span> <span class="token class-name">CameraComponent</span><span class="token punctuation">.</span><span class="token function">withFixedResolution</span><span class="token punctuation">(</span></span>
<span class="line">  world<span class="token punctuation">:</span> myWorldComponent<span class="token punctuation">,</span></span>
<span class="line">  width<span class="token punctuation">:</span> <span class="token number">800</span><span class="token punctuation">,</span></span>
<span class="line">  height<span class="token punctuation">:</span> <span class="token number">600</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This will create a camera with a viewport centered in the middle of the screen, taking as much space as possible while still maintaining the 800:600 aspect ratio, and showing a game world region of size 800 x 600.</p><p>A &quot;fixed resolution&quot; is very simple to work with, but it will underutilize the user&#39;s available screen space, unless their device happens to have the same pixel ratio as your chosen dimensions.</p><h2 id="viewport" tabindex="-1"><a class="header-anchor" href="#viewport"><span>Viewport</span></a></h2><p>The <code>Viewport</code> is a window through which the <code>World</code> is seen. That window has a certain size, shape, and position on the screen. There are multiple kinds of viewports available, and you can always implement your own.</p><p>The <code>Viewport</code> is a component, which means you can add other components to it. These children components will be affected by the viewport&#39;s position, but not by its clip mask. Thus, if a viewport is a &quot;window&quot; into the game world, then its children are things that you can put on top of the window.</p><p>Adding elements to the viewport is a convenient way to implement &quot;HUD&quot; components.</p><p>The following viewports are available:</p><ul><li><code>MaxViewport</code> (default) -- this viewport expands to the maximum size allowed by the game, i.e. it will be equal to the size of the game canvas.</li><li><code>FixedResolutionViewport</code> -- keeps the resolution and aspect ratio fixed, with black bars on the sides if it doesn&#39;t match the aspect ratio.</li><li><code>FixedSizeViewport</code> -- a simple rectangular viewport with predefined size.</li><li><code>FixedAspectRatioViewport</code> -- a rectangular viewport which expands to fit into the game canvas, but preserving its aspect ratio.</li><li><code>CircularViewport</code> -- a viewport in the shape of a circle, fixed size.</li></ul><p>If you add children to the <code>Viewport</code> they will appear as static HUDs in front of the world.</p><h2 id="viewfinder" tabindex="-1"><a class="header-anchor" href="#viewfinder"><span>Viewfinder</span></a></h2><p>This part of the camera is responsible for knowing which location in the underlying game world we are currently looking at. The <code>Viewfinder</code> also controls the zoom level, and the rotation angle of the view.</p><p>The <code>anchor</code> property of the viewfinder allows you to designate which point inside the viewport serves as a &quot;logical center&quot; of the camera. For example, in side-scrolling action games it is common to have the camera focused on the main character who is displayed not in the center of the screen but closer to the lower-left corner. This off-center position would be the &quot;logical center&quot; of the camera, controlled by the viewfinder&#39;s <code>anchor</code>.</p><p>If you add children to the <code>Viewfinder</code> they will appear will appear in front of the world, but behind the viewport and with the same transformations as are applied to the world, so these components are not static.</p>`,35)),s("p",null,[e[1]||(e[1]=a("You can also add behavioral components as children to the viewfinder, for example ")),c(o,{to:"/guide/flame/effects.html"},{default:l(()=>e[0]||(e[0]=[a("effects")])),_:1}),e[2]||(e[2]=a(" or other controllers. If you for example would add a ")),e[3]||(e[3]=s("code",null,"ScaleEffect",-1)),e[4]||(e[4]=a(" you would be able to achieve a smooth zoom in your game."))]),e[6]||(e[6]=n(`<h2 id="backdrop" tabindex="-1"><a class="header-anchor" href="#backdrop"><span>Backdrop</span></a></h2><p>To add static components behind the world you can add them to the <code>backdrop</code> component, or replace the <code>backdrop</code> component. This is for example useful if you want to have a static <code>ParallaxComponent</code> beneath a world that you can move around it.</p><p>Example:</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line">camera<span class="token punctuation">.</span>backdrop<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">MyStaticBackground</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>or</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line">camera<span class="token punctuation">.</span>backdrop <span class="token operator">=</span> <span class="token class-name">MyStaticBackground</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="camera-controls" tabindex="-1"><a class="header-anchor" href="#camera-controls"><span>Camera controls</span></a></h2><p>There are several ways to modify camera&#39;s settings at runtime:</p><ol><li><p>Do it manually. You can always override the <code>CameraComponent.update()</code> method (or the same method on the viewfinder or viewport) and within it change the viewfinder&#39;s position or zoom as you see fit. This approach may be viable in some circumstances, but in general it is not recommended.</p></li><li><p>Apply effects and/or behaviors to the camera&#39;s <code>Viewfinder</code> or <code>Viewport</code>. The effects and behaviors are special kinds of components whose purpose is to modify over time some property of a component that they attach to.</p></li><li><p>Use special camera functions such as <code>follow()</code>, <code>moveBy()</code> and <code>moveTo()</code>. Under the hood, this approach uses the same effects/behaviors as in (2).</p></li></ol><p>Camera has several methods for controlling its behavior:</p><ul><li><p><code>Camera.follow()</code> will force the camera to follow the provided target. Optionally you can limit the maximum speed of movement of the camera, or allow it to move horizontally/vertically only.</p></li><li><p><code>Camera.stop()</code> will undo the effect of the previous call and stop the camera at its current position.</p></li><li><p><code>Camera.moveBy()</code> can be used to move the camera by the specified offset. If the camera was already following another component or moving towards, those behaviors would be automatically cancelled.</p></li><li><p><code>Camera.moveTo()</code> can be used to move the camera to the designated point on the world map. If the camera was already following another component or moving towards another point, those behaviors would be automatically cancelled.</p></li><li><p><code>Camera.setBounds()</code> allows you to add limits to where the camera is allowed to go. These limits are in the form of a <code>Shape</code>, which is commonly a rectangle, but can also be any other shape.</p></li></ul><h3 id="visibleworldrect" tabindex="-1"><a class="header-anchor" href="#visibleworldrect"><span>visibleWorldRect</span></a></h3><p>The camera exposes property <code>visibleWorldRect</code>, which is a rect that describes the world&#39;s region which is currently visible through the camera. This region can be used in order to avoid rendering components that are out of view, or updating objects that are far away from the player less frequently.</p><p>The <code>visibleWorldRect</code> is a cached property, and it updates automatically whenever the camera moves or the viewport changes its size.</p><h3 id="check-if-a-component-is-visible-from-the-camera-point-of-view" tabindex="-1"><a class="header-anchor" href="#check-if-a-component-is-visible-from-the-camera-point-of-view"><span>Check if a component is visible from the camera point of view</span></a></h3><p>The <code>CameraComponent</code> has a method called <code>canSee</code> which can be used to check if a component is visible from the camera point of view. This is useful for example to cull components that are not in view.</p><div class="language-dart line-numbers-mode" data-highlighter="prismjs" data-ext="dart" data-title="dart"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>camera<span class="token punctuation">.</span><span class="token function">canSee</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">   component<span class="token punctuation">.</span><span class="token function">removeFromParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cull the component</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,17))])}const w=t(d,[["render",h],["__file","camera_component.html.vue"]]),v=JSON.parse('{"path":"/guide/flame/camera_component.html","title":"Camera component","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"World","slug":"world","link":"#world","children":[]},{"level":2,"title":"CameraComponent","slug":"cameracomponent","link":"#cameracomponent","children":[{"level":3,"title":"CameraComponent.withFixedResolution()","slug":"cameracomponent-withfixedresolution","link":"#cameracomponent-withfixedresolution","children":[]}]},{"level":2,"title":"Viewport","slug":"viewport","link":"#viewport","children":[]},{"level":2,"title":"Viewfinder","slug":"viewfinder","link":"#viewfinder","children":[]},{"level":2,"title":"Backdrop","slug":"backdrop","link":"#backdrop","children":[]},{"level":2,"title":"Camera controls","slug":"camera-controls","link":"#camera-controls","children":[{"level":3,"title":"visibleWorldRect","slug":"visibleworldrect","link":"#visibleworldrect","children":[]},{"level":3,"title":"Check if a component is visible from the camera point of view","slug":"check-if-a-component-is-visible-from-the-camera-point-of-view","link":"#check-if-a-component-is-visible-from-the-camera-point-of-view","children":[]}]}],"git":{"updatedTime":1735588798000,"contributors":[{"name":"JackYanjiaqi","username":"JackYanjiaqi","email":"jackyanjiaqi@gmail.com","commits":1,"url":"https://github.com/JackYanjiaqi"}]},"filePathRelative":"guide/flame/camera_component.md"}');export{w as comp,v as data};
